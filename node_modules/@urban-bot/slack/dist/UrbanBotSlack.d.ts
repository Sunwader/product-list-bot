import { createEventAdapter } from '@slack/events-api';
import { createMessageAdapter } from '@slack/interactive-messages';
import { WebClient } from '@slack/web-api';
import express from 'express';
import { UrbanBot, UrbanMessage, UrbanExistingMessage, UrbanSyntheticEvent, UrbanParseMode } from '@urban-bot/core';
import { SlackActionContext, SlackMessageContext, SlackPayload, SlackMessageMeta, SLACK } from './types';
export declare type SlackOptions = {
    signingSecret: string;
    token: string;
    pathnamePrefix?: string;
};
export declare type UrbanNativeEventSlack<Payload extends SlackPayload = SlackPayload> = {
    type: SLACK;
    payload?: Payload;
};
export declare type UrbanBotSlackType = {
    NativeEvent: UrbanNativeEventSlack;
    MessageMeta: SlackMessageMeta;
};
export declare class UrbanBotSlack implements UrbanBot<UrbanBotSlackType> {
    options: SlackOptions;
    static TYPE: "SLACK";
    type: "SLACK";
    defaultParseMode: UrbanParseMode;
    client: WebClient;
    events: ReturnType<typeof createEventAdapter>;
    interactions: ReturnType<typeof createMessageAdapter>;
    commandPrefix: string;
    constructor(options: SlackOptions);
    initializeServer(expressApp: express.Express): void;
    processUpdate(_event: UrbanSyntheticEvent<UrbanBotSlackType>): void;
    handleAction: (ctx: SlackActionContext) => void;
    handleMessage: (ctx: SlackMessageContext) => void;
    handleCommand: (req: express.Request<import("express-serve-static-core").ParamsDictionary, any, any, import("qs").ParsedQs>, res: express.Response<any>) => void;
    sendMessage(message: UrbanMessage): Promise<SlackMessageMeta>;
    updateMessage(message: UrbanExistingMessage<UrbanBotSlackType>): Promise<void>;
    deleteMessage(message: UrbanExistingMessage<UrbanBotSlackType>): void;
}
